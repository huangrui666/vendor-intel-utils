From cb2c9f1526ed20c099ec1a2701c99e95796bec2c Mon Sep 17 00:00:00 2001
From: Huang Rui <rui1.huang@intel.com>
Date: Thu, 20 Apr 2023 19:34:35 +0800
Subject: [PATCH] Add multi-gpu support

Use property sys.icr.gralloc.force_mem to use local memory.
Use property ro.acg.rnod to set the GPU node.

Tracked-On: OAM-10578
Change-Id: Ibee060c6e553ceb7b3e345b468ece3f0b406f631
Signed-off-by: Huang Rui <rui1.huang@intel.com>
---
 cros_gralloc/cros_gralloc_driver.cc | 12 +++++++++++-
 i915.c                              | 13 ++++++++++++-
 2 files changed, 23 insertions(+), 2 deletions(-)

diff --git a/cros_gralloc/cros_gralloc_driver.cc b/cros_gralloc/cros_gralloc_driver.cc
index 1a95eca..6c9c913 100644
--- a/cros_gralloc/cros_gralloc_driver.cc
+++ b/cros_gralloc/cros_gralloc_driver.cc
@@ -14,6 +14,7 @@
 #include "../drv_priv.h"
 #include "../helpers.h"
 #include "../util.h"
+#include <cutils/properties.h>
 
 #ifdef USE_GRALLOC1
 #include "i915_private_android.h"
@@ -66,7 +67,15 @@ int32_t cros_gralloc_driver::init()
 	uint32_t max_node = (min_node + num_nodes);
 	uint32_t j;
 	char *node;
-
+#define TARGET_DEVICE_IDX_PROP  "ro.acg.rnode"
+	char prop_buf[PROPERTY_VALUE_MAX] = {"-1"};
+	property_get(TARGET_DEVICE_IDX_PROP, prop_buf, "-1");
+	if (strcmp(prop_buf, "-1")) {
+	    drv_log("Render name set by property is (%s)",prop_buf);
+		min_node = atoi(prop_buf)+128;
+		num_nodes = 1;
+		max_node = (min_node + num_nodes);
+	}
 	const int render_num = 10;
 	const int name_length = 50;
 	int node_fd[render_num];
@@ -101,6 +110,7 @@ int32_t cros_gralloc_driver::init()
 		free(node);
 		if (fd < 0)
 			continue;
+		drv_log("open(%s)", node);
 
 		version = drmGetVersion(fd);
 		if (!version) {
diff --git a/i915.c b/i915.c
index 107e4b6..cfea436 100644
--- a/i915.c
+++ b/i915.c
@@ -16,6 +16,7 @@
 #include <sys/mman.h>
 #include <unistd.h>
 #include <xf86drm.h>
+#include <cutils/properties.h>
 
 #include "drv_priv.h"
 #include "helpers.h"
@@ -69,6 +70,7 @@ struct i915_device {
 	bool is_adlp;
 	int32_t has_mmap_offset;
 	bool has_local_mem;
+	bool force_mem_local;
 	bool has_fence_reg;
 	struct iris_memregion vram, sys;
 };
@@ -510,6 +512,15 @@ static int i915_init(struct driver *drv)
 	i915->has_fence_reg = gem_param(drv->fd, I915_PARAM_NUM_FENCES_AVAIL) > 0;
 
 	i915_bo_query_meminfo(drv, i915);
+#define FORCE_MEM_PROP "sys.icr.gralloc.force_mem"
+	char prop[PROPERTY_VALUE_MAX];
+	i915->force_mem_local = (i915->vram.size > 0) &&
+				property_get(FORCE_MEM_PROP, prop, "local") > 0 &&
+				!strcmp(prop, "local");
+	if (i915->force_mem_local) {
+		drv_log("Force to use local memory");
+	}
+
 	drv->priv = i915;
 
 #ifdef USE_GRALLOC1
@@ -709,7 +720,7 @@ static int i915_bo_create_from_metadata(struct bo *bo)
 		} else {
 				struct prelim_drm_i915_gem_memory_class_instance regions[2];
 				uint32_t nregions = 0;
-				if (1) {
+				if (i915_dev->force_mem_local) {
 					/* For vram allocations, still use system memory as a fallback. */
 					regions[nregions++] = i915_dev->vram.region;
 					regions[nregions++] = i915_dev->sys.region;
-- 
2.25.1

